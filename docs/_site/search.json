[
  {
    "objectID": "imate_compare.html",
    "href": "imate_compare.html",
    "title": "Comparison to imate",
    "section": "",
    "text": "Much of primate’s computational code was ported from the (excellent) imate package, prompting questions about their differences.\nIn general, primate was developed with slightly different goals in mind than imate, most of which have to do with integrability and the choice of FFI / build system.\nNotable differences between the two packages include:\n\n\n\nFeature\nprimate\nimate\n\n\n\n\nTrace methods\nSLQ only\nMultiple\n\n\nParallel support\nCPU only\nCPU & GPU\n\n\nFunction support\nArbitrary\nPackage supported1\n\n\nOperator support\nArbitrary\nMatrix-derived\n\n\nLinking strategy\nHeader only\nShared libraries\n\n\nC++ version\n\\(\\geq\\) C++20\nAny\n\n\nFFI\nPybind11\nCython\n\n\nBuild tool\nMeson\nCMake\n\n\n\nOne of the primary motivations for developing primate was to streamline access to SLQ method from user (i.e. dependent) packages, as well as to extend native support for types adhering to SciPys LinearOperator abstract interface.\nIf this fits your use case, consider giving primate a try!\n\n\n\n\n\n\nFootnotes\n\n\nSee imates documentation for the list of supported functions.↩︎",
    "crumbs": [
      "Comparison to *imate*"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Package overview",
    "section": "",
    "text": "primate, short for Probabalistic Implicit Matrix Trace Estimator, is Python package that performs randomized matrix trace estimation of matrix functions—that is, matrices parameterized by functions:\n\\[ \\mathrm{tr}(f(A)) \\triangleq \\mathrm{tr}(U f(\\Lambda) U^{\\intercal}), \\quad \\quad f : [a,b] \\to \\mathbb{R}\\]\nTrace estimates are obtained in a Monte-Carlo fashion via the stochastic Lanczos method (SLQ)1. This method is useful for sparse or highly structured matrices with efficiently computable quadratic forms.\nNotable features of primate include:\n\nA highly-parametrizable trace estimator (see SLQ)\nVarious distribution / engine choices for random vector generation (the stochastic part!)\nOrthogonalization routines, such as the Lanczos, Golub Kahan, and Gram Schmidt methods\nSupport for arbitrary matrix functions, i.e. Callable’s (Python) and invocable’s2 (C++)\nSupport for arbitrary LinearOperator’s, e.g. those in SciPy or Pylops\n\nMuch of primate’s computational code was directly ported from the (excellent) imate package; for a a comparison of the two, see here.\n\n\n\n\nFootnotes\n\n\nUbaru, S., Chen, J., & Saad, Y. (2017). Fast estimation of tr(f(A)) via stochastic Lanczos quadrature. SIAM Journal on Matrix Analysis and Applications, 38(4), 1075-1099.↩︎\nThis includes std::function’s, C-style function pointers, functors, and lambda expressions.↩︎",
    "crumbs": [
      "Overview"
    ]
  },
  {
    "objectID": "install.html",
    "href": "install.html",
    "title": "Installation",
    "section": "",
    "text": "primate is a standard PEP-517 package, and thus can be installed via pip:\npip install &lt; primate source directory &gt;\nCurrently the package must be built from source via cloning the repository. PYPI support is planned.\n\nCompiling extension modules\nprimate’s C++ interface is exported as a header-only library, making it easy to compile your own extension modules using primate’s API.\nThe simplest way to link to these headers is to include primate as a dependency to your package and use the get_include() function to find the appropriate directory (this is how NumPy is exported).\n\nsetuptoolsmeson-pythongit submodule\n\n\n# setup.py\nimport primate as pm\n...\nExtension('extension_name', ..., include_dirs=[pm.get_include()])\n...\n\n\n# meson.build\n...\nprimate_include_dirs = run_command(py, \n  ['-c', 'import primate as pm; print(pm.get_include())']\n).stdout().strip()\n...\n\n\nAssuming your headers are located in extern, from your git repository, you can use:\ngit submodule add https://github.com/peekxc/primate extern/primate\ngit submodule update --init\nFrom here, you can now include extern/primate/include into your C++ source files, or you can add this directory to the search path used other various build tools, such as CMake or Meson.\n\n\n\n\n\nC++ Integration\nprimate uses a generic template interface via C++20 Concepts; thus, and supplying types fitting the constraints.\nFor example,\nPYBIND11_MODULE(_custom_ext_module, m) {\n  _trace&lt; false, float, Eigen::SparseMatrix&lt; float &gt; &gt;(m); // &lt; symmetric &gt;\n}",
    "crumbs": [
      "Installation"
    ]
  },
  {
    "objectID": "install.html#usage-with-c",
    "href": "install.html#usage-with-c",
    "title": "Installation",
    "section": "Usage with C++",
    "text": "Usage with C++\nprimate’s core C++ interface is exported as a header-only library, making it easy to compile custom extension modules in a separate package against primate’s API.\nThe simplest way is to do this is to add primate as a dependency to your package and use the get_include() function to include the header files (this is similar to how NumPy is exported).\n\nsetuptoolsmeson-pythongit submodule\n\n\n# setup.py\nimport primate as pm\n...\nExtension('extension_name', ..., include_dirs=[pm.get_include()])\n...\n\n\n# meson.build\n...\nprimate_include_dirs = run_command(py, \n  ['-c', 'import primate as pm; print(pm.get_include())']\n).stdout().strip()\n...\n\n\nAssuming your headers are located in extern, from your git repository, you can use:\ngit submodule add https://github.com/peekxc/primate extern/primate\ngit submodule update --init\nFrom here, you can now include extern/primate/include into your C++ source files, or you can add this directory to the search path used other various build tools, such as CMake or Meson.\n\n\n\n\nIntegration\nprimate uses a generic template interface via C++20 Concepts—thus, and supplying types fitting the constraints. This makes it incredibly easy to e.g. add a non-standard matrix function or compile the trace estimator with custom linear operator (todo: document this).",
    "crumbs": [
      "Installation"
    ]
  },
  {
    "objectID": "install.html#linking-the-library",
    "href": "install.html#linking-the-library",
    "title": "Installation",
    "section": "Linking the library",
    "text": "Linking the library\nprimate’s core C++ interface is exported as a header-only library, making it easy to compile custom extension modules in a separate package against primate’s API.\nThe simplest way is to do this is to add primate as a dependency to your package and use the get_include() function to include the header files (this is similar to how NumPy is exported).\n\nsetuptoolsmeson-pythongit submodule\n\n\n# setup.py\nimport primate as pm\n...\nExtension('extension_name', ..., include_dirs=[pm.get_include()])\n...\n\n\n# meson.build\n...\nprimate_include_dirs = run_command(py, \n  ['-c', 'import primate as pm; print(pm.get_include())']\n).stdout().strip()\n...\n\n\nAssuming your headers are located in extern, from your git repository, you can use:\ngit submodule add https://github.com/peekxc/primate extern/primate\ngit submodule update --init\nFrom here, you can now include extern/primate/include into your C++ source files, or you can add this directory to the search path used other various build tools, such as CMake or Meson.\n\n\n\n\nIntegration\nprimate uses a generic template interface via C++20 Concepts—thus, and supplying types fitting the constraints. This makes it incredibly easy to e.g. add a non-standard matrix function or compile the trace estimator with custom linear operator (todo: document this).",
    "crumbs": [
      "Installation"
    ]
  },
  {
    "objectID": "install.html#compiling-extension-modules",
    "href": "install.html#compiling-extension-modules",
    "title": "Installation",
    "section": "Compiling extension modules",
    "text": "Compiling extension modules\nprimate’s C++ interface is exported as a header-only library, making it easy to compile your own extension modules using primate’s API.\nThe simplest way to link to these headers is to include primate as a dependency to your package and use the get_include() function to find the appropriate directory (this is how NumPy is exported).\n\nsetuptoolsmeson-pythongit submodule\n\n\n# setup.py\nimport primate as pm\n...\nExtension('extension_name', ..., include_dirs=[pm.get_include()])\n...\n\n\n# meson.build\n...\nprimate_include_dirs = run_command(py, \n  ['-c', 'import primate as pm; print(pm.get_include())']\n).stdout().strip()\n...\n\n\nAssuming your headers are located in extern, from your git repository, you can use:\ngit submodule add https://github.com/peekxc/primate extern/primate\ngit submodule update --init\nFrom here, you can now include extern/primate/include into your C++ source files, or you can add this directory to the search path used other various build tools, such as CMake or Meson.\n\n\n\n\nIntegration\nprimate uses a generic template interface via C++20 Concepts—thus, and supplying types fitting the constraints. This makes it incredibly easy to e.g. add a non-standard matrix function or compile the trace estimator with custom linear operator (todo: document this).",
    "crumbs": [
      "Installation"
    ]
  },
  {
    "objectID": "integration.html",
    "href": "integration.html",
    "title": "Integration",
    "section": "",
    "text": "primate supports calling the SLQ trace estimator directly from C++ using any matrix function and any linear operator having the preqrequisite member functions. For explanatory purposes, the following code outline how to call the trace estimator to compute teh log determinant using a custom user-implemented operator LinOp:\n#include &lt;cmath&gt;                              // std::log\n#include &lt;_linear_operator/linear_operator.h&gt; // LinearOperator\n#include &lt;_trace_estimator/trace_estimator.h&gt; // trace_estimator\n#include \"LinOp.h\"                            // custom LinOp class\n\nvoid slq_log_det(LinOp A, ...){ // LinOp must support .matvec() and .shape()\n  static_assert(LinearOperator&lt; LinOp &gt;);  // compile-time constraint check\n  static constexpr bool gramian = false;   // whether to compute the gramian\n  using float_t = A::value_type;           // the value type of the vectors\n  const auto matrix_func = std::log;       // any invocable will due\n  trace_estimator&lt; gramian, float_t &gt;(\n    A, matrix_func, ...                    // for ..., see arguments below\n  ) \n}\nAny object respecting the LinearOperator concept can be given to the trace estimator; in words, the requirements are that the custom type LinOp have the following member functions:\n\nA matvec function A.matvec(const float_t* v, float_t* o) implementing \\(Av \\mapsto o\\)\nA shape function A.shape() returning the (output, input) dimensions\n\nFor example, in the matrix setting, shape() should yield a pair (r,c) where r and c indicates the number of rows and columns, respectively.\nMore concretely, the actual C++ concept itself is given as follows:\ntemplate &lt; typename T, typename F = typename T::value_type &gt;\nconcept LinearOperator = requires(T op, const F* input, F* output) {\n  { op.matvec(input, output) }; // o = A v\n  { op.shape() } -&gt; std::convertible_to&lt; std::pair&lt; size_t, size_t &gt; &gt;;\n};\nOther concepts must be met depending on the parameter choices and template specializations. For example, the boolean gramian determines whether to compute \\(\\mathrm{tr}(f(A^T A))\\) [true] or \\(\\mathrm{tr}(f(A))\\) [false]—if gramian = true, then A must also implement rmatvec(...) method, satisfying \\(A^T v \\mapsto o\\).\nThe trace estimator is fully configurable and thus has many parameters, both compile-time and run-time. It’s full signature is given below:\ntemplate&lt; \n  bool gramian, \n  std::floating_point DataType, \n  Operator Matrix, \n  ThreadSafeRBG RBG, \n  std::invocable&lt; DataType &gt; Func \n&gt; FlagType trace_estimator(\n    Matrix* A,\n    const DataType* parameters,\n    const IndexType num_parameters,\n    Func&& matrix_function,\n    RBG& rng,\n    const IndexType distr,\n    const FlagType orthogonalize,\n    const IndexType lanczos_degree,\n    const DataType lanczos_tol,\n    const IndexType min_num_samples,\n    const IndexType max_num_samples,\n    const DataType error_atol,\n    const DataType error_rtol,\n    const DataType confidence_level,\n    const DataType outlier_significance_level,\n    const IndexType num_threads,\n    DataType* trace,\n    DataType* error,\n    DataType** samples,\n    IndexType* processed_samples_indices,\n    IndexType* num_samples_used,\n    IndexType* num_outliers,\n    FlagType* converged,\n    DataType& alg_wall_time\n  )",
    "crumbs": [
      "Integration"
    ]
  },
  {
    "objectID": "integration.html#any-object-respecting-the-linearoperator-concept-can-be-given-to-the-trace-estimatorthe-only-requirements-here-are",
    "href": "integration.html#any-object-respecting-the-linearoperator-concept-can-be-given-to-the-trace-estimatorthe-only-requirements-here-are",
    "title": "Integration",
    "section": "Any object respecting the LinearOperator concept can be given to the trace estimator—the only requirements here are:",
    "text": "Any object respecting the LinearOperator concept can be given to the trace estimator—the only requirements here are:\n\n\n\ntemplate &lt; typename T, typename F = typename T::value_type &gt;\nconcept LinearOperator = requires(T op, const F* input, F* output) {\n  { op.matvec(input, output) }; // y = A x \n  { op.shape() } -&gt; std::convertible_to&lt; std::pair&lt; size_t, size_t &gt; &gt;;\n};\n\ntemplate &lt; typename T, typename F = typename T::value_type &gt;\nconcept AdjointOperator = requires(T op, const F* input, F* output) {\n  { op.rmatvec(input, output) }; // y = A^T x \n} && LinearOperator&lt; T, F &gt;;\nis the availability of a member function A.matvec(const float_t* v, float_t* o) -&gt; void and a shape function A.shape() -&gt; pair&lt; size_t, size_t &gt;, where the former implements the operation \\(Av \\mapsto o\\) and the latter yields a pair (r,c) where r and c indicate the output and input dimensions, respectively.\nOther concepts must be met depending on the operator. For example, if gramian = true, then A must also implement rmatvec(...) method, satisfying the\n\\[A^T v \\mapsto o\\]\nwhether to compute tr(f(A)^T f(A)) [true] or tr(f(A)) [false]\ntemplate&lt; bool gramian, std::floating_point DataType, Operator Matrix, ThreadSafeRBG RBG, std::invocable&lt; DataType &gt; Func &gt; \nFlagType trace_estimator(\n    Matrix* A,\n    const DataType* parameters,\n    const IndexType num_parameters,\n    Func&& matrix_function,\n    RBG& rng,\n    const IndexType distr,\n    const FlagType orthogonalize,\n    const IndexType lanczos_degree,\n    const DataType lanczos_tol,\n    const IndexType min_num_samples,\n    const IndexType max_num_samples,\n    const DataType error_atol,\n    const DataType error_rtol,\n    const DataType confidence_level,\n    const DataType outlier_significance_level,\n    const IndexType num_threads,\n    DataType* trace,\n    DataType* error,\n    DataType** samples,\n    IndexType* processed_samples_indices,\n    IndexType* num_samples_used,\n    IndexType* num_outliers,\n    FlagType* converged,\n    DataType& alg_wall_time\n  )",
    "crumbs": [
      "Integration"
    ]
  }
]