{
  "hash": "c57aab11a03c30e0a4c1c0b2bc95085b",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"`primate` quickstart\"\n---\n\n\n\n\n`primate` is a package that contains a variety of algorithms for estimating quantities from matrix functions, with a focus \non implicit matrix representations and support for common quantities of interest, such as the trace or the diagonal.\n\nBelow is a quick introduction to: \n\n- Trace estimation\n- Diagonal estimation \n- Matrix function approximation\n- Configuring the output \n- Configuring the execution\n\n<br/>\n\n\n\n## Trace estimation \n\nA variety of _trace_ estimators are available in the `primate.trace` module. These algorithms estimate the quantity: \n\n$$ \\mathrm{tr}(A) = \\sum\\limits_{i=1}^n A_{ii} = \\sum\\limits_{i=1}^n \\lambda_i $$\n\nThe following example demonstrates a variety of trace estimators, including the Girard-Hutchinson estimator (`hutch`), the \nimproved Hutch++ (`hutchpp`), and XTrace (`xtrace`):\n\n::: {#b7c83e5a .cell execution_count=2}\n``` {.python .cell-code}\nfrom primate.trace import hutch, hutchpp, xtrace\nfrom primate.random import symmetric\nrng = np.random.default_rng(1234)      # for reproducibility \nA = symmetric(150, pd=True, seed=rng)  # random PD matrix \n\nprint(f\"Trace   :  {A.trace():6f}\")   ## Actual trace\nprint(f\"Hutch   :  {hutch(A):6f}\")    ## Crude Monte-Carlo estimator\nprint(f\"Hutch++ :  {hutchpp(A):6f}\")  ## Monte-Carlo estimator w/ deflation \nprint(f\"XTrace  :  {xtrace(A):6f}\")   ## Epperly's algorithm\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTrace   :  74.884261\nHutch   :  74.420094\nHutch++ :  74.944518\nXTrace  :  74.884261\n```\n:::\n:::\n\n\nHere, `A` can be a numpy matrix, a sparse matrix, or a `LinearOperator`. If the spectral sum of interest is not just the sum of the eigenvalues, but rather the sum under composition with some spectral function $f(\\lambda)$, i.e. the quantity of interest is of the form: \n\n$$ \\mathrm{tr}(f(A)) = \\sum\\limits_{i=1}^n f(A)_{ii} = \\sum\\limits_{i=1}^n f(\\lambda_i) $$\n\nThen you may alternatively use the `matrix_function` API to construct a `LinearOperator` by passing in the corresponding spectral function as a `Callable` or by passing a string representing the name of one of the following built-in spectral functions:\n\n| **name**       | **matrix function**       | **Applications**                          | **numpy call**                     |\n|----------------|---------------------------|-------------------------------------------|------------------------------------|\n| identity       | $A$                      | Basic matrix operations                   | `A`                                |\n| log            | $\\log(A)$                | Determinant, entropy-like measures        | `logm(A)`                         |\n| exp            | $e^A$                    | Dynamical systems, graph diffusion        | `expm(A)`                         |\n| inv            | $A^{-1}$                 | Stability analysis, linear systems        | `inv(A)`                          |\n| sign           | $\\text{sgn}_\\epsilon(A)$ | Rank approximation, low-rank modeling     | `U @ U.T`                         |\n| sqrt           | $A^{1/2}$                | Diffusion, kernel methods                 | `sqrtm(A)`                        |\n| square         | $A^2$                    | Energy measures, stability                | `A @ A`                           |\n| PCA            | $P_A$ (eigenspace)       | Dim. reduction, feature extraction        | Custom projection matrix          |\n| Tikhonov       | $(A + \\lambda I)^{-1}$   | Regularized inversion, stability          | `inv(A + lambda * eye(n))`        |\n| heat           | $e^{-tA}$                | Diffusion on graphs, spectral clustering  | `expm(-t * A)`                    |\n| pagerank       | $(I - \\alpha A)^{-1}v$   | Network centrality, web ranking           | Iterative solver                  |\n\n<br/>\n\nFor example, one might compute the log-determinant of a positive definite matrix as follows:\n\n::: {#a9910018 .cell execution_count=3}\n``` {.python .cell-code}\nfrom primate.operators import matrix_function, IdentityOperator\nM = matrix_function(A, fun=\"log\") # or fun=np.log \n\nprint(f\"logdet(A) :  {np.log(np.linalg.det(A)):6f}\")\nprint(f\"tr(log(A)):  {np.sum(np.log(np.linalg.eigvalsh(A))):6f}\")\nprint(f\"Hutch     :  {hutch(M):6f}\")\nprint(f\"Hutch++   :  {hutchpp(M):6f}\")\nprint(f\"XTrace    :  {xtrace(M):6f}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nlogdet(A) :  -151.529763\ntr(log(A)):  -151.529763\nHutch     :  -152.753783\nHutch++   :  -151.046977\nXTrace    :  -151.528096\n```\n:::\n:::\n\n\n## Diagonal estimation \n\nThe diagonals of matrices and matrix functions (implicitly or explicitly represented) can also be estimated via nearly identical API used for the trace.  \n\n::: {#49fad444 .cell execution_count=4}\n``` {.python .cell-code}\nfrom primate.estimators import arr_summary\nfrom primate.diagonal import diag, xdiag\n\nd1 = A.diagonal()\nd2 = diag(A, rtol=1e-4)\nd3 = xdiag(A)\n\nprint(f\"Diagonal (true): {arr_summary(d1)}\")\nprint(f\"Diagonal Hutch : {arr_summary(d2)}\")\nprint(f\"Diagonal XDiag : {arr_summary(d3)}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nDiagonal (true): [0.48,0.53,...,0.48]\nDiagonal Hutch : [0.49,0.58,...,0.52]\nDiagonal XDiag : [0.48,0.53,...,0.48]\n```\n:::\n:::\n\n\n## Matrix function approximation \n\nIn `primate`, the matrix function $f(A)$ is not constructed explicitly but instead the action $v \\mapsto f(A)v$ is approximated with a fixed-degree Krylov expansion. This can be useful when, for example, the matrix $A$ itself is so large that the corresponding (typically dense) matrix function $f(A) \\in \\mathbb{R}^{n \\times n}$ simply is too large to be explicitly represented. If you just want to approximate the action of a matrix function for a single vector $v \\in \\mathbb{R}^n$, simply supply the vector and the matrix alongside the `matrix_function` call: \n\n::: {#576dee98 .cell execution_count=5}\n``` {.python .cell-code}\nfrom primate.operators import matrix_function\nv = np.random.uniform(size=A.shape[0])\ny = matrix_function(A, fun=np.exp, v=v)\nprint(f\"f(A)v = {arr_summary(y.ravel())}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nf(A)v = [0.52,0.90,...,0.24]\n```\n:::\n:::\n\n\nAlternatively, if you prefer an object-oriented approach (or you plan on doing multiple matvecs), you can construct a `MatrixFunction` instance and use it like any other `LinearOperator`: \n\n::: {#139f4d52 .cell execution_count=6}\n``` {.python .cell-code}\nfrom primate.operators import MatrixFunction\nExpA = MatrixFunction(A, fun=np.exp)\ny = ExpA @ v\nprint(f\"exp(A)v = {arr_summary(y)}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nexp(A)v = [0.52,0.90,...,0.24]\n```\n:::\n:::\n\n\nIf you don't supply a vector `v` to the `matrix_function` call, a `MatrixFunction` instance is constructed using whatever additional arguments are passed in and returned. Note some function specializations are inherently more difficult to approximate and can depend on the smoothness of $f$ and the conditioning of the corresponding operator $f(A)$; in general, a `MatrixFunction` instance with degree $k$ approximates the action $v \\mapsto f(A)v$ about as well as the operator $p(A)$, where $p$ is a degree $2k-1$ polynomial interpolant of $f$. \n\n::: {#5607a442 .cell execution_count=7}\n``` {.python .cell-code}\nfrom scipy.linalg import expm\nExpA = expm(A)\nExpA0 = MatrixFunction(A, fun=np.exp, deg=5, orth=0)\nExpA1 = MatrixFunction(A, fun=np.exp, deg=20, orth=0)\nExpA2 = MatrixFunction(A, fun=np.exp, deg=50, orth=50)\n\nw = ExpA @ v\nx = ExpA0 @ v\ny = ExpA1 @ v \nz = ExpA2 @ v\n\nprint(f\"Deg-5 approx error  (no reorth.)   : {np.linalg.norm(w - x)}\")\nprint(f\"Deg-20 approx error (no reorth.)   : {np.linalg.norm(w - y)}\")\nprint(f\"Deg-50 approx error (full reorth.) : {np.linalg.norm(w - z)}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nDeg-5 approx error  (no reorth.)   : 0.0001254249077837913\nDeg-20 approx error (no reorth.)   : 8.246535086916179e-14\nDeg-50 approx error (full reorth.) : 9.442567959828599e-14\n```\n:::\n:::\n\n\nAs you can see, for smoother matrix functions (like $\\mathrm{exp}(A)$), even a low degree Krylov expansion can be more than sufficient for many application purposes---all without any re-orthogonalization! See the matrix function guide for more background on this. \n\n## Configuring the output\n\n<!-- By default, the various estimators offered by `primate` simply return the estimated quantity under reasonable default parameter settings. However, in many applications one would like to have greater control over both the computation itself and the type of information collected during execution.  -->\n\nPassing `full=True` returns additional information about the computation in the form of `EstimatorResult` (along with the estimate itself), which contains information about execution itself, convergence information of the estimator, and other status messages. \n\nFor example, with the default `converge=\"confidene\"` criterion, the margin of error of a default-constructed confidence interval is returned: \n\n::: {#a7c3e703 .cell execution_count=8}\n``` {.python .cell-code}\nest, info = hutch(A, converge=\"confidence\", full=True)\nprint(info.message)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nEst: 74.443 +/- 1.393 (95% CI, #S:32)\n```\n:::\n:::\n\n\nA more visual way of viewing the sample values and the corresponding estimate as a function of the sample size is to plot the sequence with \nthe `figure_sequence` function (note this requires saving the samples with `record=True`):\n\n::: {#ffb57673 .cell execution_count=9}\n``` {.python .cell-code}\nfrom primate.plotting import figure_sequence\n\nest, info = hutch(A, full=True, record=True)\np = figure_sequence(info.estimator.values)\nshow(p)\n```\n\n::: {.cell-output .cell-output-display}\n```{=html}\n\n  <div id=\"acc78b0e-4be2-4ed9-b8de-defedc15c9d2\" data-root-id=\"p2201\" style=\"display: contents;\"></div>\n```\n:::\n\n::: {.cell-output .cell-output-display}\n```{=html}\n<script type=\"application/javascript\">\n(function(root) {\n  function embed_document(root) {\n  const docs_json = {\"fc3047d4-35da-44cc-aa41-cf78ca47d22f\":{\"version\":\"3.5.2\",\"title\":\"Bokeh Application\",\"roots\":[{\"type\":\"object\",\"name\":\"Figure\",\"id\":\"p2201\",\"attributes\":{\"width\":400,\"height\":300,\"x_range\":{\"type\":\"object\",\"name\":\"DataRange1d\",\"id\":\"p2202\"},\"y_range\":{\"type\":\"object\",\"name\":\"DataRange1d\",\"id\":\"p2203\"},\"x_scale\":{\"type\":\"object\",\"name\":\"LinearScale\",\"id\":\"p2211\"},\"y_scale\":{\"type\":\"object\",\"name\":\"LinearScale\",\"id\":\"p2212\"},\"title\":{\"type\":\"object\",\"name\":\"Title\",\"id\":\"p2204\",\"attributes\":{\"text\":\"Monte Carlo sample variates\",\"align\":\"center\"}},\"renderers\":[{\"type\":\"object\",\"name\":\"GlyphRenderer\",\"id\":\"p2242\",\"attributes\":{\"data_source\":{\"type\":\"object\",\"name\":\"ColumnDataSource\",\"id\":\"p2236\",\"attributes\":{\"selected\":{\"type\":\"object\",\"name\":\"Selection\",\"id\":\"p2237\",\"attributes\":{\"indices\":[],\"line_indices\":[]}},\"selection_policy\":{\"type\":\"object\",\"name\":\"UnionRenderers\",\"id\":\"p2238\"},\"data\":{\"type\":\"map\",\"entries\":[[\"x\",{\"type\":\"ndarray\",\"array\":{\"type\":\"bytes\",\"data\":\"AQAAAAIAAAADAAAABAAAAAUAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAABEAAAASAAAAEwAAABQAAAAVAAAAFgAAABcAAAAYAAAAGQAAABoAAAAbAAAAHAAAAB0AAAAeAAAAHwAAACAAAAAhAAAAIgAAACMAAAAkAAAAJQAAACYAAAAnAAAAKAAAACkAAAAqAAAAKwAAACwAAAAtAAAALgAAAC8AAAAwAAAAMQAAADIAAAAzAAAANAAAADUAAAA2AAAANwAAADgAAAA5AAAAOgAAADsAAAA8AAAAPQAAAD4AAAA/AAAAQAAAAEEAAABCAAAAQwAAAEQAAABFAAAARgAAAEcAAABIAAAASQAAAEoAAABLAAAATAAAAE0AAABOAAAATwAAAFAAAABRAAAAUgAAAFMAAABUAAAAVQAAAFYAAABXAAAAWAAAAFkAAABaAAAAWwAAAFwAAABdAAAAXgAAAF8AAABgAAAAYQAAAGIAAABjAAAAZAAAAGUAAABmAAAAZwAAAGgAAABpAAAAagAAAGsAAABsAAAAbQAAAG4AAABvAAAAcAAAAHEAAAByAAAAcwAAAHQAAAB1AAAAdgAAAHcAAAB4AAAAeQAAAHoAAAB7AAAAfAAAAH0AAAB+AAAAfwAAAIAAAAA=\"},\"shape\":[128],\"dtype\":\"int32\",\"order\":\"little\"}],[\"y\",{\"type\":\"ndarray\",\"array\":{\"type\":\"bytes\",\"data\":\"92jvmNFPUEBypTB5ay5VQPuSFYJwvVFAncqDk0fnUUDhR2T6LehSQCQqnkQVuVNAzghGun7SVECGIaPjkuZSQGL/hSNn01FA+iBZzRgCUECuLBPeX79SQLhffFgopFJAbQI+Eb2cUUBl+4B8aPVUQLMwBCgIhVJA4YNbvWinUEDMQloLv1FSQOMcE/3ejlFAiNZbO6cQUEAw6wiXb/JTQIFPBUuiIFJACDO8A5ycUkAjCFpfAXpUQEzvVrAc6VRACYDw3SJBVUDEaqJ3ocJRQFakFBLpQFNAxiVHLMSiU0BdCvcUp2ZTQGWZbzQCtlNAhi4A4RTaUkAA7DCdtNhRQGNgZSeTylFA8gkljPE4U0CjtyQY3cJSQHV+Fi3JJlNAU9udzBywUkCkZUcmdjhTQOBCNnxGJlFAnLdEIiAoU0CvF6nlQJBRQGa6blUZhFJAya3SY27vUkA3/bAV+e9TQMC+SMkYxlNAydaf4v+OUkBnhSYb3QNUQDudurz1fVNA5jFQHu9XVECnj35WS2BRQGZQ3ZzWQlRAFidlZxAJUkBzob7nyfhTQM2P9857glFA7mTdHFibU0CYFU3Yi59SQPzUzPX4pFJAEfhANEkIUUB3z3nKLE5TQJet8ddQblJA1IjgTnwPU0AvirodNjNSQAMQiAVcplJAmBPvv3RoUkA0WbOPXMRSQIGuxOBERlFAk11ZzJU8U0BX6V4s6VdRQEQivKLyIlNAiCX9OoMKU0CbCKJUL/NTQAOd7c0jF1FAuswq0mi4VEDeU1BeN+1RQO1VF0bE7lFAnWVRxXDbTkAqn8qphGZUQKpBeQ3S4FJAMhf7UrEZUUA0E2B7+NtRQEo0R6Z5GFBAMYMZw2X6UkBGWv5SAmFTQGQQhPaY1VFAa1VXPhosVEDvx2GoOHlTQJ+jTWN8LlRA1WUHjuf5UkDDsnwho2VSQMcOgRDlFlBAf9jKj9WbVEApskarKCdVQMJG/8rvalFA0T6Ft4fRUkA8iaT39xdRQP64Eh8vllJAoKmgEdY4UkA3DFAv3xlTQJDa/CSyvlNAxwJip0CKUECha5BzsQtTQKQUUYrBV1FAq5wI8cuaVEC9bObXQAxTQMw1Ei8rx1FAE4Mh5cThUkB0sS1UDMhTQJo+RHIxelNAwCq5hhWVVEBni5onXElRQK7CftBK91JA4ZkRM+76UUCDKieiL9NRQJ8ofcJiylBAQBVaOSTlUkDd1GwOpRJSQNllFoz51lFASmvaU9NRUkC0WLgAaHpRQJD0ouU5tVJAh2xhKXs5U0B9YFkGUQxTQPnu4XfXZlNAeopVYxXGVEDlplyZwdBUQJ3GjyWt4lFAogC4EIxbUkAlWQ8vDG5UQA==\"},\"shape\":[128],\"dtype\":\"float64\",\"order\":\"little\"}]]}}},\"view\":{\"type\":\"object\",\"name\":\"CDSView\",\"id\":\"p2243\",\"attributes\":{\"filter\":{\"type\":\"object\",\"name\":\"AllIndices\",\"id\":\"p2244\"}}},\"glyph\":{\"type\":\"object\",\"name\":\"Scatter\",\"id\":\"p2239\",\"attributes\":{\"x\":{\"type\":\"field\",\"field\":\"x\"},\"y\":{\"type\":\"field\",\"field\":\"y\"},\"line_color\":{\"type\":\"value\",\"value\":\"gray\"},\"hatch_color\":{\"type\":\"value\",\"value\":\"gray\"}}},\"nonselection_glyph\":{\"type\":\"object\",\"name\":\"Scatter\",\"id\":\"p2240\",\"attributes\":{\"x\":{\"type\":\"field\",\"field\":\"x\"},\"y\":{\"type\":\"field\",\"field\":\"y\"},\"line_color\":{\"type\":\"value\",\"value\":\"gray\"},\"line_alpha\":{\"type\":\"value\",\"value\":0.1},\"fill_alpha\":{\"type\":\"value\",\"value\":0.1},\"hatch_color\":{\"type\":\"value\",\"value\":\"gray\"},\"hatch_alpha\":{\"type\":\"value\",\"value\":0.1}}},\"muted_glyph\":{\"type\":\"object\",\"name\":\"Scatter\",\"id\":\"p2241\",\"attributes\":{\"x\":{\"type\":\"field\",\"field\":\"x\"},\"y\":{\"type\":\"field\",\"field\":\"y\"},\"line_color\":{\"type\":\"value\",\"value\":\"gray\"},\"line_alpha\":{\"type\":\"value\",\"value\":0.2},\"fill_alpha\":{\"type\":\"value\",\"value\":0.2},\"hatch_color\":{\"type\":\"value\",\"value\":\"gray\"},\"hatch_alpha\":{\"type\":\"value\",\"value\":0.2}}}}},{\"type\":\"object\",\"name\":\"GlyphRenderer\",\"id\":\"p2253\",\"attributes\":{\"data_source\":{\"type\":\"object\",\"name\":\"ColumnDataSource\",\"id\":\"p2247\",\"attributes\":{\"selected\":{\"type\":\"object\",\"name\":\"Selection\",\"id\":\"p2248\",\"attributes\":{\"indices\":[],\"line_indices\":[]}},\"selection_policy\":{\"type\":\"object\",\"name\":\"UnionRenderers\",\"id\":\"p2249\"},\"data\":{\"type\":\"map\",\"entries\":[[\"x\",{\"type\":\"ndarray\",\"array\":{\"type\":\"bytes\",\"data\":\"AQAAAAIAAAADAAAABAAAAAUAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAABEAAAASAAAAEwAAABQAAAAVAAAAFgAAABcAAAAYAAAAGQAAABoAAAAbAAAAHAAAAB0AAAAeAAAAHwAAACAAAAAhAAAAIgAAACMAAAAkAAAAJQAAACYAAAAnAAAAKAAAACkAAAAqAAAAKwAAACwAAAAtAAAALgAAAC8AAAAwAAAAMQAAADIAAAAzAAAANAAAADUAAAA2AAAANwAAADgAAAA5AAAAOgAAADsAAAA8AAAAPQAAAD4AAAA/AAAAQAAAAEEAAABCAAAAQwAAAEQAAABFAAAARgAAAEcAAABIAAAASQAAAEoAAABLAAAATAAAAE0AAABOAAAATwAAAFAAAABRAAAAUgAAAFMAAABUAAAAVQAAAFYAAABXAAAAWAAAAFkAAABaAAAAWwAAAFwAAABdAAAAXgAAAF8AAABgAAAAYQAAAGIAAABjAAAAZAAAAGUAAABmAAAAZwAAAGgAAABpAAAAagAAAGsAAABsAAAAbQAAAG4AAABvAAAAcAAAAHEAAAByAAAAcwAAAHQAAAB1AAAAdgAAAHcAAAB4AAAAeQAAAHoAAAB7AAAAfAAAAH0AAAB+AAAAfwAAAIAAAAA=\"},\"shape\":[128],\"dtype\":\"int32\",\"order\":\"little\"}],[\"y\",{\"type\":\"ndarray\",\"array\":{\"type\":\"bytes\",\"data\":\"92jvmNFPUEA0BxCJHr9SQHfgEdw5aVJAAFvuSb1IUkAtV2ygoGhSQKtPHxG0oFJAi0UAl/XwUkALoZRAqe9SQL85Ia8T0FJAEgRaZUeIUkBPNt+eSY1SQBdPrIMxj1JARoS3BIt8UkARn7Nov6lSQC0PyspMp1JAeCbziU6HUkAyN/n6J4RSQEoZF3uHdlJAg5xQTzhWUkAMOoCs1GpSQEJH9C1MZ1JAV0YgibhpUkDxsnCSsIBSQMpKWr5fmlJA4XW8RIa1UkDCYQCzLqxSQPfoctywsVJAbX26+ky6UkBSTWRuPsBSQP3xqJ9vyFJA8fNxVwHJUkCx65/xfsFSQAQWYG8DulJAfGjtJL+9UkCFwkaS5L1SQBPdIXrOwFJAyfHm+FrAUkBpzMcbhMNSQFLC143ruFJADuLARLO7UkB7ZlyNZbRSQHtogSo/s1JANds7eaW0UkBvbeEZ0LtSQETK9PW6wVJA+MQOoqDAUkDfDyU9gcdSQCfYIlVOy1JAvaUJg2bTUkD6bMly+stSQEdJQhlU01JAKabWVXDPUkB4RWKXDNVSQEnjMIrHzlJA2BgYsn/SUkCA5g/FltFSQIsyHGPO0FJAblC3Zu/IUkCwoMeGMctSQCtlmT+lyVJAGK0HWcrKUkDCExt5WMhSQBDr417Ox1JAshdo+FDGUkCNopBFScZSQD+yKMB3wFJAV6l5/VHCUkB1Fwyg/bxSQEs1lOZ3vlJA3oFiAY6/UkDdQgk148NSQB3EYcXuvVJA6yKg6N7EUkCiyWDc9MFSQEPB6/8jv1JALUtTy/azUkBqlbiLm7lSQO6DnT4culJAOkgt19a0UkDD6m3cILJSQNg9fRHpqVJA3I9WWOSqUkCp6D8OFq1SQFP1D1SFqlJAUdIWnA6vUkCvk6ZmaLFSQHMP8rvJtVJAnaom5I+2UkDoSF4ep7VSQGXqRy8zrlJASVLC3p+zUkBJ+oANcrpSQBHPZoDWtlJA310CMh+3UkCvQHV3wLJSQPA5NEl0slJA32+MUDOxUkBOeey9RLJSQLDCaNv6tFJAF/lJwW6vUkDz5X+aWLBSQPDt/L/3rFJAZG5lIcOxUkCHhLDgobJSQIM/fstjsFJAOUzxDNuwUkD+RW4Gd7NSQOzFphVOtVJA3GG357S5UkDb9HWpW7ZSQOPKimvxtlJAc9pSrUO1UkAbQep/Q7NSQI9rKqv5rlJAeOdSP3KvUkCEKd4zGK5SQOgcZINBrFJAVmdCU32rUkDEGfgC7ahSQB9kl0AHqVJAg8UT3ziqUkBTkm61BqtSQHa29JuNrFJA0UxvWeOwUkB/dvwwPbVSQHdMqGGRs1JAKnIr9N+yUkD4OaFMVrZSQA==\"},\"shape\":[128],\"dtype\":\"float64\",\"order\":\"little\"}]]}}},\"view\":{\"type\":\"object\",\"name\":\"CDSView\",\"id\":\"p2254\",\"attributes\":{\"filter\":{\"type\":\"object\",\"name\":\"AllIndices\",\"id\":\"p2255\"}}},\"glyph\":{\"type\":\"object\",\"name\":\"Line\",\"id\":\"p2250\",\"attributes\":{\"x\":{\"type\":\"field\",\"field\":\"x\"},\"y\":{\"type\":\"field\",\"field\":\"y\"},\"line_width\":1.5}},\"nonselection_glyph\":{\"type\":\"object\",\"name\":\"Line\",\"id\":\"p2251\",\"attributes\":{\"x\":{\"type\":\"field\",\"field\":\"x\"},\"y\":{\"type\":\"field\",\"field\":\"y\"},\"line_alpha\":0.1,\"line_width\":1.5}},\"muted_glyph\":{\"type\":\"object\",\"name\":\"Line\",\"id\":\"p2252\",\"attributes\":{\"x\":{\"type\":\"field\",\"field\":\"x\"},\"y\":{\"type\":\"field\",\"field\":\"y\"},\"line_alpha\":0.2,\"line_width\":1.5}}}}],\"toolbar\":{\"type\":\"object\",\"name\":\"Toolbar\",\"id\":\"p2210\",\"attributes\":{\"tools\":[{\"type\":\"object\",\"name\":\"PanTool\",\"id\":\"p2223\"},{\"type\":\"object\",\"name\":\"WheelZoomTool\",\"id\":\"p2224\",\"attributes\":{\"renderers\":\"auto\"}},{\"type\":\"object\",\"name\":\"BoxZoomTool\",\"id\":\"p2225\",\"attributes\":{\"overlay\":{\"type\":\"object\",\"name\":\"BoxAnnotation\",\"id\":\"p2226\",\"attributes\":{\"syncable\":false,\"line_color\":\"black\",\"line_alpha\":1.0,\"line_width\":2,\"line_dash\":[4,4],\"fill_color\":\"lightgrey\",\"fill_alpha\":0.5,\"level\":\"overlay\",\"visible\":false,\"left\":{\"type\":\"number\",\"value\":\"nan\"},\"right\":{\"type\":\"number\",\"value\":\"nan\"},\"top\":{\"type\":\"number\",\"value\":\"nan\"},\"bottom\":{\"type\":\"number\",\"value\":\"nan\"},\"left_units\":\"canvas\",\"right_units\":\"canvas\",\"top_units\":\"canvas\",\"bottom_units\":\"canvas\",\"handles\":{\"type\":\"object\",\"name\":\"BoxInteractionHandles\",\"id\":\"p2232\",\"attributes\":{\"all\":{\"type\":\"object\",\"name\":\"AreaVisuals\",\"id\":\"p2231\",\"attributes\":{\"fill_color\":\"white\",\"hover_fill_color\":\"lightgray\"}}}}}}}},{\"type\":\"object\",\"name\":\"SaveTool\",\"id\":\"p2233\"},{\"type\":\"object\",\"name\":\"ResetTool\",\"id\":\"p2234\"},{\"type\":\"object\",\"name\":\"HelpTool\",\"id\":\"p2235\"}]}},\"toolbar_location\":null,\"left\":[{\"type\":\"object\",\"name\":\"LinearAxis\",\"id\":\"p2218\",\"attributes\":{\"ticker\":{\"type\":\"object\",\"name\":\"BasicTicker\",\"id\":\"p2219\",\"attributes\":{\"mantissas\":[1,2,5]}},\"formatter\":{\"type\":\"object\",\"name\":\"BasicTickFormatter\",\"id\":\"p2220\"},\"axis_label\":\"Estimates\",\"major_label_policy\":{\"type\":\"object\",\"name\":\"AllLabels\",\"id\":\"p2221\"}}}],\"below\":[{\"type\":\"object\",\"name\":\"LinearAxis\",\"id\":\"p2213\",\"attributes\":{\"ticker\":{\"type\":\"object\",\"name\":\"BasicTicker\",\"id\":\"p2214\",\"attributes\":{\"mantissas\":[1,2,5]}},\"formatter\":{\"type\":\"object\",\"name\":\"BasicTickFormatter\",\"id\":\"p2215\"},\"axis_label\":\"Sample index\",\"major_label_policy\":{\"type\":\"object\",\"name\":\"AllLabels\",\"id\":\"p2216\"}}}],\"center\":[{\"type\":\"object\",\"name\":\"Grid\",\"id\":\"p2217\",\"attributes\":{\"axis\":{\"id\":\"p2213\"}}},{\"type\":\"object\",\"name\":\"Grid\",\"id\":\"p2222\",\"attributes\":{\"dimension\":1,\"axis\":{\"id\":\"p2218\"}}},{\"type\":\"object\",\"name\":\"Legend\",\"id\":\"p2245\",\"attributes\":{\"location\":\"top_left\",\"title_text_font_size\":\"11px\",\"label_text_font_size\":\"11px\",\"margin\":4,\"padding\":4,\"spacing\":2,\"items\":[{\"type\":\"object\",\"name\":\"LegendItem\",\"id\":\"p2246\",\"attributes\":{\"label\":{\"type\":\"value\",\"value\":\"samples\"},\"renderers\":[{\"id\":\"p2242\"}]}},{\"type\":\"object\",\"name\":\"LegendItem\",\"id\":\"p2256\",\"attributes\":{\"label\":{\"type\":\"value\",\"value\":\"estimator\"},\"renderers\":[{\"id\":\"p2253\"}]}}]}}]}}]}};\n  const render_items = [{\"docid\":\"fc3047d4-35da-44cc-aa41-cf78ca47d22f\",\"roots\":{\"p2201\":\"acc78b0e-4be2-4ed9-b8de-defedc15c9d2\"},\"root_ids\":[\"p2201\"]}];\n  void root.Bokeh.embed.embed_items_notebook(docs_json, render_items);\n  }\n  if (root.Bokeh !== undefined) {\n    embed_document(root);\n  } else {\n    let attempts = 0;\n    const timer = setInterval(function(root) {\n      if (root.Bokeh !== undefined) {\n        clearInterval(timer);\n        embed_document(root);\n      } else {\n        attempts++;\n        if (attempts > 100) {\n          clearInterval(timer);\n          console.log(\"Bokeh: ERROR: Unable to run BokehJS code because BokehJS library is missing\");\n        }\n      }\n    }, 10, root)\n  }\n})(window);\n</script>\n```\n:::\n:::\n\n\n<!-- For example, consider applying the `sign` function at some tolerance level $\\epsilon$:\n\n$$ \\mathrm{sign}_\\epsilon(x) = \\begin{align} 1 & x \\geq \\epsilon \\\\ 0 & \\text{otherwise} \\end{align} $$\n\nThe spectral sum defined by applying this function corresponds to the numerical rank of the operator, which is an interesting and sometimes useful quantity to estimate. However, the sign function itself is discontinuous (at $\\epsilon$) and otherwise not smooth; thus, it cannot be well approximated by any polynomial of finite degree. Non-analytic functions such as these can prove difficult to approximate, as shown below:\n\n\new = np.sort(np.random.uniform(size=150, low=0, high=1))\new[:30] = 0.0\nA = symmetric(150, ew = ew, pd = False)\nM = matrix_function(A, fun=\"numrank\")\n\nprint(f\"numrank(A): {np.linalg.matrix_rank(A)}\")\nprint(f\"GR approx:  {hutch(M)}\")\nprint(f\"Hutch++ :   {hutchpp(M)}\")\nprint(f\"XTrace:     {xtrace(M)}\")\n``` -->\n<!-- from timeit import timeit\ntimeforlan = timeit(lambda: ExpA @ v, number=100)/100\n\ntimeforexpmA = timeit(lambda: expm(A), number=100)/100\nB = expm(A)\ntimeforexpmAv = timeit(lambda: B @ v, number=100)/100\n\nsample_index = 1 + np.arange(30)\ntimeforsp = timeforexpmA + timeforexpmAv * sample_index\ntimeformf = timeforlan * sample_index\n\np = figure(width=350, height=200)\n\np.line(sample_index, timeforsp, color='red')\np.scatter(sample_index, timeforsp, color='red',  size=1)\np.line(sample_index, timeformf, color='blue')\np.scatter(sample_index, timeformf, color='blue', size=1)\nshow(p) -->\n\n",
    "supporting": [
      "quickstart_files"
    ],
    "filters": [],
    "includes": {
      "include-in-header": [
        "<script src=\"https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js\" integrity=\"sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==\" crossorigin=\"anonymous\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js\" integrity=\"sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==\" crossorigin=\"anonymous\" data-relocate-top=\"true\"></script>\n<script type=\"application/javascript\">define('jquery', [],function() {return window.jQuery;})</script>\n"
      ]
    }
  }
}