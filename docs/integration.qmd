---
title: "Integration"
---

`primate` supports calling the SLQ trace estimator directly from C++ using any matrix function and any linear operator having the preqrequisite member functions. For explanatory purposes, the following code outline how to call the trace estimator to compute teh log determinant using a custom user-implemented operator `LinOp`: 

```cpp
#include <cmath>                              // std::log
#include <_linear_operator/linear_operator.h> // LinearOperator
#include <_trace_estimator/trace_estimator.h> // trace_estimator
#include "LinOp.h"                            // custom LinOp class

void slq_log_det(LinOp A, ...){ // LinOp must support .matvec() and .shape()
  static_assert(LinearOperator< LinOp >);  // compile-time constraint check
  static constexpr bool gramian = false;   // whether to compute the gramian
  using float_t = A::value_type;           // the value type of the vectors
  const auto matrix_func = std::log;       // any invocable will due
  trace_estimator< gramian, float_t >(
    A, matrix_func, ...                    // for ..., see arguments below
  ) 
}
```

Any object respecting the `LinearOperator` _concept_ can be given to the trace estimator; in words, the requirements are that the custom type `LinOp` have the following member functions: 

1. A matvec function `A.matvec(const float_t* v, float_t* o)` implementing $Av \mapsto o$ 
2. A shape function `A.shape()` returning the (output, input) dimensions

For example, in the matrix setting, `shape()` should yield a pair `(r,c)` where `r` and `c` indicates the number of rows and columns, respectively.

More concretely, the actual C++ concept itself is given as follows: 
```cpp
template < typename T, typename F = typename T::value_type >
concept LinearOperator = requires(T op, const F* input, F* output) {
  { op.matvec(input, output) }; // o = A v
  { op.shape() } -> std::convertible_to< std::pair< size_t, size_t > >;
};
```

Other concepts must be met depending on the parameter choices and template specializations. For example, the boolean `gramian` determines whether to compute $\mathrm{tr}(f(A^T A))$ [true] or $\mathrm{tr}(f(A))$ [false]---if `gramian = true`, then `A` must also implement `rmatvec(...)` method, satisfying $A^T v \mapsto o$. 

The trace estimator is fully configurable and thus has many parameters, both compile-time and run-time. 
It's full signature is given below: 

```cpp
template< 
  bool gramian, 
  std::floating_point DataType, 
  Operator Matrix, 
  ThreadSafeRBG RBG, 
  std::invocable< DataType > Func 
> FlagType trace_estimator(
    Matrix* A,
    const DataType* parameters,
    const IndexType num_parameters,
    Func&& matrix_function,
    RBG& rng,
    const IndexType distr,
    const FlagType orthogonalize,
    const IndexType lanczos_degree,
    const DataType lanczos_tol,
    const IndexType min_num_samples,
    const IndexType max_num_samples,
    const DataType error_atol,
    const DataType error_rtol,
    const DataType confidence_level,
    const DataType outlier_significance_level,
    const IndexType num_threads,
    DataType* trace,
    DataType* error,
    DataType** samples,
    IndexType* processed_samples_indices,
    IndexType* num_samples_used,
    IndexType* num_outliers,
    FlagType* converged,
    DataType& alg_wall_time
  )
  ```