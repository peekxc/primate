---
title: "pybind11 Integration"
---

If you're using pybind11, you can easily incorporate your own custom linear operator / matrix function pair using `primate`s _binding_ headers. The idea as follows: let's suppose you have your own `LinearOperator` class called `LinOp`, which defined as follows: 

```cpp
class LinOp {
  int nrow, ncol;
  
  LinOp(int nr, int nc) : nrow(nr), ncol(nc) {}
  
  void matvec(const float* input, float* output) const {
    ... // implementation details 
  }

  void shape() const { return std::make_pair(nrow, ncol); }
}
```

This class is a pure C++ class, though one could easily expose the type for construction on the Python side using [pybind11's class-binding code](https://pybind11.readthedocs.io/en/stable/advanced/classes.html). This part is optional. 

Suppose you want to create an extension module that calls `primate`'s SLQ trace estimator with your custom operator `LinOp`. 
Since `LinOp` already satisfies the `LinearOperator` constraints, this is achieved by calling the `_trace_wrapper` function: 

```cpp
#include <binders/pb11_trace_bind.h>  // _trace_wrapper binding  
#include "LinOp.h"                    // custom LinOp class  

PYBIND11_MODULE(_custom_trace, m) {   
  // m is the actual py::module (exported as _custom_trace)
  m.doc() = "custom trace estimator module";
  _trace_wrapper< false, float, LinOp >(m); 
}
```

The final extension module `_custom_trace` will have a method `trace_slq` as an attribute that can be called from Python to initiate the SLQ method with the corresponding `LineOp` type. If you're trying to create bindings for a class that doesn't natively support the `matvec` and `shape` constraints, you can optionally provide a wrapper function to the last template parameter: 

```cpp
struct WrappedLinOp {
  LinOp op;

  void WrappedLinOp(LinOp& _op) : op(_op){ }

  void matvec(const float* input, float* output){
    ... // implementation details, e.g. op.dot(input, output)
  }

  void shape() { ... }
}

void linop_wrapper(LinOp* op){
  return WrappedLinOp(*op);
}

PYBIND11_MODULE(_custom_trace, m) {   
  // m is the actual py::module (exported as _custom_trace)
  m.doc() = "custom trace estimator module";
  _trace_wrapper< false, float, LinOp, linop_wrapper >(m); 
}
```

As a final example, here's what the code might look like for wrapping a [Eigen]() SparseMatrix for use with `primate`'s underlying trace estimator. 

```cpp
template< std::floating_point F >
struct SparseEigenLinearOperator {
  using value_type = F;
  using float_vec = Eigen::Matrix< F, Eigen::Dynamic, 1 >;

  const Eigen::SparseMatrix< F > A;  
  SparseEigenLinearOperator(const Eigen::SparseMatrix< F >& _mat) : A(_mat){}

  void matvec(const F* inp, F* out) const noexcept {
    auto input = Eigen::Map< const float_vec >(inp, A.cols(), 1); 
    auto output = Eigen::Map< float_vec >(out, A.rows(), 1);
    output = A * input; 
  }

  auto shape() const noexcept -> std::pair< size_t, size_t > {
    return std::make_pair((size_t) A.rows(), (size_t) A.cols());
  }
};

template< std::floating_point F >
auto eigen_sparse_wrapper(const Eigen::SparseMatrix< F >* A){
  return SparseEigenLinearOperator< F >(*A);
}

PYBIND11_MODULE(_custom_trace, m) {
  m.doc() = "custom trace estimator module";
  _trace_wrapper< false, float, Eigen::SparseMatrix< float > >(m, eigen_sparse_wrapper< float >); 
}
```
