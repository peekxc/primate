[
  {
    "objectID": "pybind11_integration.html",
    "href": "pybind11_integration.html",
    "title": "pybind11 Integration",
    "section": "",
    "text": "If you’re using pybind11, you can easily incorporate your own custom linear operator / matrix function pair using primates binding headers.\n\nNative pybind11 types\nSuppose you have a custom class LinOp understood by pybind11, which looks something like:\nclass LinOp {\n  int nrow, ncol;\n  \n  LinOp(int nr, int nc) : nrow(nr), ncol(nc) {}\n  \n  void matvec(const float* input, float* output) const {\n    ... // implementation details \n  }\n\n  void shape() const { return std::make_pair(nrow, ncol); }\n}\nSince pybind11 understands how to pass a pointer to this type natively, creating an extension module that calls primate’s SLQ trace estimator with LinOp can be done by just calling the _trace_wrapper function:\n#include &lt;binders/pb11_trace_bind.h&gt;  // _trace_wrapper binding  \n#include \"LinOp.h\"                    // custom LinOp class  \n\nPYBIND11_MODULE(_custom_trace, m) {   \n  // m is the actual py::module (exported as _custom_trace)\n  m.doc() = \"custom trace estimator module\";\n  _trace_wrapper&lt; false, float, LinOp &gt;(m); \n}\nThe final extension module _custom_trace will have a method trace_slq as an attribute that can be called from Python to initiate the SLQ method with the corresponding LineOp type.\n\n\nWrapping types\nIf you’re trying to create bindings for a class that isn’t known to pybind11, or it doesn’t natively support the matvec and shape constraints, you can optionally provide a wrapper function to the last template parameter of _trace_wrapper:\nstruct WrappedLinOp {\n  LinOp op;\n\n  void WrappedLinOp(LinOp& _op) : op(_op){ }\n\n  void matvec(const float* input, float* output){\n    ... // implementation details, e.g. op.dot(input, output)\n  }\n\n  void shape() { ... }\n}\n\nvoid linop_wrapper(LinOp* op){ // or py::object, for non-native types\n  return WrappedLinOp(*op); \n}\n\nPYBIND11_MODULE(_custom_trace, m) {   \n  // m is the actual py::module (exported as _custom_trace)\n  m.doc() = \"custom trace estimator module\";\n  _trace_wrapper&lt; false, float, LinOp, linop_wrapper &gt;(m); \n}\nAs a side effect, this also enables full access to matrix types that implement matrix-vector multiplication but don’t have the matching method names / signatures available needed to match the underlying LinearOperaor concept.\n\n\nFull Example using Eigen\nHere’s a real example of what simple code might look like that wraps a Eigen SparseMatrix for use with primate. Eigen supports matrix-vector multiplication out of the box with the overloaded operator*() and is understood natively by pybind11, thus it suffices to define wrapper class that respects the LinearOperator concept:\ntemplate&lt; std::floating_point F &gt;\nstruct SparseEigenLinearOperator {\n  using value_type = F;\n  using float_vec = Eigen::Matrix&lt; F, Eigen::Dynamic, 1 &gt;;\n\n  const Eigen::SparseMatrix&lt; F &gt; A;  \n  SparseEigenLinearOperator(const Eigen::SparseMatrix&lt; F &gt;& _mat) : A(_mat){}\n\n  void matvec(const F* inp, F* out) const noexcept {\n    auto input = Eigen::Map&lt; const float_vec &gt;(inp, A.cols(), 1); \n    auto output = Eigen::Map&lt; float_vec &gt;(out, A.rows(), 1);\n    output = A * input; \n  }\n\n  auto shape() const noexcept -&gt; std::pair&lt; size_t, size_t &gt; {\n    return std::make_pair((size_t) A.rows(), (size_t) A.cols());\n  }\n};\nThen, simply write a quick wrapper function that converts a Eigen::SparseMatrix&lt; F &gt;* type to a SparseEigenLinearOperator&lt; F &gt; types and incorporate with _trace_wrapper\ntemplate&lt; std::floating_point F &gt;\nauto eigen_sparse_wrapper(const Eigen::SparseMatrix&lt; F &gt;* A){\n  return SparseEigenLinearOperator&lt; F &gt;(*A);\n}\n\nPYBIND11_MODULE(_custom_trace, m) {\n  m.doc() = \"custom trace estimator module\";\n  _trace_wrapper&lt; false, float, Eigen::SparseMatrix&lt; float &gt; &gt;(\n    m, eigen_sparse_wrapper&lt; float &gt;\n  ); \n}\nThat’s it. The module _custom_trace will now have an exported trace_slq method that you can call from Python. For a list of arguments, it’s recommended to see the slq declaration in trace.py.",
    "crumbs": [
      "Usage with pybind11"
    ]
  },
  {
    "objectID": "reference/trace.slq.html",
    "href": "reference/trace.slq.html",
    "title": "trace.slq",
    "section": "",
    "text": "trace.slq(A, matrix_function='identity', parameters=None, min_num_samples=10, max_num_samples=50, error_atol=None, error_rtol=0.01, confidence_level=0.95, outlier_significance_level=0.001, distribution='rademacher', rng_engine='pcg', seed=-1, lanczos_degree=20, lanczos_tol=None, orthogonalize=0, num_threads=0, verbose=False, plot=False, return_info=False, **kwargs)\nEstimates the trace of a matrix function \\(f(A) = U f(D) U^{-1}\\) using the stochastic Lanczos quadrature (SLQ) method.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nA\nndarray, sparse matrix, or LinearOperator\nreal, square, symmetric operator given as a ndarray, a sparse matrix, or a LinearOperator.\nrequired\n\n\nmatrix_function\nstr or Callable\nfloat-valued function defined on the spectrum of A.\n\"identity\"\n\n\nparameters\nIterable\ntranslates ‘t’ for the affine operator A + t*B (see details).\n= None\n\n\nmin_num_samples\nint\nMinimum number of random vectors to sample for the trace estimate.\n= 10\n\n\nmax_num_samples\nint\nMaximum number of random vectors to sample for the trace estimate.\n= 50\n\n\nerror_atol\nfloat\nAbsolute tolerance governing convergence.\n= None\n\n\nerror_rtol\nfloat\nRelative tolerance governing convergence.\n= 1e-2\n\n\nconfidence_level\nfloat\nConfidence level before converging.\n= 0.95\n\n\noutlier_significance_level\nfloat\nOutliers to ignore in trace estimation.\n0.001\n\n\ndistribution\nstr\nzero-centered distribution to sample random vectors from.\n'rademacher'\n\n\n**kwargs\n(dict, optional)\nadditional key-values to parameterize the chosen ‘matrix_function’.\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nfloat\nEstimate of the trace of the matrix function \\(f(A)\\).\n\n\n(dict, optional)\nIf ‘return_info = True’, additional information about the computation.\n\n\n\n\n\n\nlanczos : the lanczos algorithm.\n\n\n\n.. [1] Ubaru, S., Chen, J., and Saad, Y. (2017) &lt;https://www-users.cs.umn.edu/~saad/PDF/ys-2016-04.pdf&gt;_, Fast Estimation of :math:\\mathrm{tr}(F(A)) Via Stochastic Lanczos Quadrature, SIAM J. Matrix Anal. Appl., 38(4), 1075-1099.",
    "crumbs": [
      "API Reference",
      "trace.slq"
    ]
  },
  {
    "objectID": "reference/trace.slq.html#parameters",
    "href": "reference/trace.slq.html#parameters",
    "title": "trace.slq",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\nA\nndarray, sparse matrix, or LinearOperator\nreal, square, symmetric operator given as a ndarray, a sparse matrix, or a LinearOperator.\nrequired\n\n\nmatrix_function\nstr or Callable\nfloat-valued function defined on the spectrum of A.\n\"identity\"\n\n\nparameters\nIterable\ntranslates ‘t’ for the affine operator A + t*B (see details).\n= None\n\n\nmin_num_samples\nint\nMinimum number of random vectors to sample for the trace estimate.\n= 10\n\n\nmax_num_samples\nint\nMaximum number of random vectors to sample for the trace estimate.\n= 50\n\n\nerror_atol\nfloat\nAbsolute tolerance governing convergence.\n= None\n\n\nerror_rtol\nfloat\nRelative tolerance governing convergence.\n= 1e-2\n\n\nconfidence_level\nfloat\nConfidence level before converging.\n= 0.95\n\n\noutlier_significance_level\nfloat\nOutliers to ignore in trace estimation.\n0.001\n\n\ndistribution\nstr\nzero-centered distribution to sample random vectors from.\n'rademacher'\n\n\n**kwargs\n(dict, optional)\nadditional key-values to parameterize the chosen ‘matrix_function’.\n{}",
    "crumbs": [
      "API Reference",
      "trace.slq"
    ]
  },
  {
    "objectID": "reference/trace.slq.html#returns",
    "href": "reference/trace.slq.html#returns",
    "title": "trace.slq",
    "section": "",
    "text": "Type\nDescription\n\n\n\n\nfloat\nEstimate of the trace of the matrix function \\(f(A)\\).\n\n\n(dict, optional)\nIf ‘return_info = True’, additional information about the computation.",
    "crumbs": [
      "API Reference",
      "trace.slq"
    ]
  },
  {
    "objectID": "reference/trace.slq.html#see-also",
    "href": "reference/trace.slq.html#see-also",
    "title": "trace.slq",
    "section": "",
    "text": "lanczos : the lanczos algorithm.",
    "crumbs": [
      "API Reference",
      "trace.slq"
    ]
  },
  {
    "objectID": "reference/trace.slq.html#reference",
    "href": "reference/trace.slq.html#reference",
    "title": "trace.slq",
    "section": "",
    "text": ".. [1] Ubaru, S., Chen, J., and Saad, Y. (2017) &lt;https://www-users.cs.umn.edu/~saad/PDF/ys-2016-04.pdf&gt;_, Fast Estimation of :math:\\mathrm{tr}(F(A)) Via Stochastic Lanczos Quadrature, SIAM J. Matrix Anal. Appl., 38(4), 1075-1099.",
    "crumbs": [
      "API Reference",
      "trace.slq"
    ]
  },
  {
    "objectID": "reference/random.rademacher.html",
    "href": "reference/random.rademacher.html",
    "title": "random.rademacher",
    "section": "",
    "text": "random.rademacher(size, engine='splitmix64', num_threads=1, seed=-1, dtype=np.float32)\nGenerates random vectors from the rademacher distribution.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nsize\nint or tuple\nthe output shape to generate\nrequired",
    "crumbs": [
      "API Reference",
      "random.rademacher"
    ]
  },
  {
    "objectID": "reference/random.rademacher.html#parameters",
    "href": "reference/random.rademacher.html#parameters",
    "title": "random.rademacher",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\nsize\nint or tuple\nthe output shape to generate\nrequired",
    "crumbs": [
      "API Reference",
      "random.rademacher"
    ]
  },
  {
    "objectID": "imate_compare.html",
    "href": "imate_compare.html",
    "title": "Comparison to imate",
    "section": "",
    "text": "Much of primate’s computational code was ported from the (excellent) imate package, prompting questions about their differences. In general, primate was developed with slightly different goals in mind than imate, most of which have to do with integrability and the choice of FFI / build system.\nNotable differences between the two packages include:\n\n\n\nFeature\nprimate\nimate\n\n\n\n\nTrace methods\nSLQ only\nMultiple\n\n\nParallel support\nCPU only\nCPU & GPU\n\n\nFunction support\nArbitrary\nPackage supported1\n\n\nOperator support\nArbitrary\nMatrix-derived\n\n\nLinking strategy\nHeader only\nShared libraries\n\n\nC++ version\n\\(\\geq\\) C++20\nAny\n\n\nFFI\nPybind11\nCython\n\n\nBuild tool\nMeson\nCMake\n\n\n\nOne of the primary motivations for developing primate was to streamline access to SLQ method from user (i.e. dependent) packages, as well as to extend native support for types adhering to SciPys LinearOperator abstract interface. If this fits your use case, consider giving primate a try!\n\n\n\n\n\n\nFootnotes\n\n\nSee imates documentation for the list of supported functions.↩︎",
    "crumbs": [
      "Comparison to *imate*"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Package overview",
    "section": "",
    "text": "primate, short for Probabalistic Implicit Matrix Trace Estimator, is Python package that performs randomized matrix trace estimation of matrix functions—that is, matrices parameterized by functions:\n\\[ \\mathrm{tr}(f(A)) \\triangleq \\mathrm{tr}(U f(\\Lambda) U^{\\intercal}), \\quad \\quad f : [a,b] \\to \\mathbb{R}\\]\nTrace estimates are obtained in a Monte-Carlo fashion via the stochastic Lanczos method (SLQ)1. This method is useful for sparse or highly structured matrices with efficiently computable quadratic forms.\nNotable features of primate include:\n\nA highly-parametrizable trace estimator (see SLQ)\nVarious distribution / engine choices for random vector generation (the stochastic part!)\nOrthogonalization routines, such as the Lanczos, Golub Kahan, and Gram Schmidt methods\nSupport for arbitrary matrix functions, i.e. Callable’s (Python) and invocable’s2 (C++)\nSupport for arbitrary LinearOperator’s, e.g. those in SciPy or Pylops\n\nMuch of primate’s computational code was directly ported from the (excellent) imate package—for a comparison of the two, see here.\n\n\n\n\nFootnotes\n\n\nUbaru, S., Chen, J., & Saad, Y. (2017). Fast estimation of tr(f(A)) via stochastic Lanczos quadrature. SIAM Journal on Matrix Analysis and Applications, 38(4), 1075-1099.↩︎\nThis includes std::function’s, C-style function pointers, functors, and lambda expressions.↩︎",
    "crumbs": [
      "Overview"
    ]
  },
  {
    "objectID": "install.html",
    "href": "install.html",
    "title": "Installation",
    "section": "",
    "text": "primate is a standard PEP-517 package, and thus can be installed via pip:\npip install &lt; primate source directory &gt;\nCurrently the package must be built from source via cloning the repository. PYPI support is planned.\n\nCompiling extension modules\nprimate’s C++ interface is header-only, making it easy to compile your own extension modules. The simplest way to link these headers is to add primate as a dependency to your package and use the get_include() function to find the appropriate directory.\n\nsetuptoolsmeson-pythongit submodule\n\n\n# setup.py\nimport primate as pm\n...\nExtension('extension_name', ..., include_dirs=[pm.get_include()])\n...\n\n\n# meson.build\n...\nprimate_include_dirs = run_command(py, \n  ['-c', 'import primate as pm; print(pm.get_include())']\n).stdout().strip()\n...\n\n\nAssuming your headers are located in extern, from your git repository, you can use:\ngit submodule add https://github.com/peekxc/primate extern/primate\ngit submodule update --init\nFrom here, you can now include extern/primate/include into your C++ source files, or you can add this directory to the search path used other various build tools, such as CMake or Meson.\n\n\n\n\n\nIntegration\nOn the Python side, primate uses a supports a variety of matrix-types of the box, including numpy ndarray’s, compressed sparse matrices (a lá SciPy), and any LinearOperator.\nIn general, primate supports any operator posessing the following methods:\n\nA method A.matvec(input: ndarray) -&gt; ndarray implementing \\(v \\mapsto Av\\)\nA method A.shape() -&gt; tuple yielding the matrix dimensions (A.nrow(), A.ncol())\n\nThis support extends to the C++ side as well—see the C++ integration guide. If you’re using pybind11 and you want to be able to create your own trace estimator from Python, see the pybind11 integration guide.",
    "crumbs": [
      "Installation"
    ]
  },
  {
    "objectID": "integration.html",
    "href": "integration.html",
    "title": "Integration",
    "section": "",
    "text": "primate relies on the use of C++20’s concepts to support calling the SLQ trace estimator using any matrix function and any linear operator having the preqrequisite member functions. To understand this more in detail, examples are given below.",
    "crumbs": [
      "Usage with C++"
    ]
  },
  {
    "objectID": "integration.html#the-linearoperator-concept",
    "href": "integration.html#the-linearoperator-concept",
    "title": "Integration",
    "section": "the LinearOperator concept",
    "text": "the LinearOperator concept\nAny class respecting the LinearOperator concept can be given to the trace estimator.\ntemplate &lt; typename T, typename F = typename T::value_type &gt;\nconcept LinearOperator = requires(T op, const F* v, F* o) {\n  { op.matvec(v, o) }; // o = A v\n  { op.shape() } -&gt; std::convertible_to&lt; std::pair&lt; size_t, size_t &gt; &gt;;\n};\nThus, a given instance A must support member functions:\n\nA method \\(Av \\mapsto o\\), with signature A.matvec(const float_t* v, float_t* o)\nA method yielding \\((\\mathrm{card}(o), \\mathrm{card}(v))\\), with signatureA.shape() -&gt; pair&lt; ... &gt;\n\nFor example, in the matrix setting, shape() should yield a pair (r,c) where r and c indicates the number of rows and columns, respectively.",
    "crumbs": [
      "Usage with C++"
    ]
  },
  {
    "objectID": "integration.html#example-the-linop-class",
    "href": "integration.html#example-the-linop-class",
    "title": "Integration",
    "section": "Example: the LinOp class",
    "text": "Example: the LinOp class\nHere’s the declarations for a bare-bones C++ class respecting the concept:\nclass LinOp {\n  int nrow, ncol;\n  \n  LinOp(int nr, int nc) : nrow(nr), ncol(nc) {}\n  \n  void matvec(const float* input, float* output) const {\n    ... // implementation details \n  }\n\n  void shape() const { return std::make_pair(nrow, ncol); }\n}\nNote that it is up to the user to ensure shape() yields the correct size sizes. primate only guarentees the pointer to the output will be at least as large as the size reported by the first parameter of shape().",
    "crumbs": [
      "Usage with C++"
    ]
  },
  {
    "objectID": "integration.html#other-concepts",
    "href": "integration.html#other-concepts",
    "title": "Integration",
    "section": "Other Concepts",
    "text": "Other Concepts\nDepending on the parameter choices and particular template specializations, the supplied operator may need to meet other constraints. Here’s a short list additional operator concepts:\n\n\n\n\n\n\n\n\n\nConcept\nSupports\nSignature\nRequires\n\n\n\n\nLinearOperator\n\\(o = o + A v\\)\nA.matvec(v, o)\nNA\n\n\nAdjointOperator\n\\(o = o + A^T v\\)\nA.rmatvec(v, o)\nLinearOperator\n\n\nLinearAdditiveOperator\n\\(o \\gets o + \\alpha Av\\)\nA.matvec_add(v, alpha, o)\nLinearOperator\n\n\nAffineOperator\nSets \\(t\\) s.t. \\(A + tB\\)\nA.set_parameter(t)\nLinearOperator\n\n\n\nRespecting these constraints is opt-in: if your operator is symmetric and you only need access to the Lanczos method, then any satisfying the LinearOperator concept is sufficient. However, if you e.g. want to compute the trace of the gramian \\(f(A^T A)\\) of a given operator via Golub-Kahan,the operator must also satisfy the AdjointOperator concept. For a full list of the supported concepts, see linearoperator.h.",
    "crumbs": [
      "Usage with C++"
    ]
  },
  {
    "objectID": "integration.html#slq-parameters",
    "href": "integration.html#slq-parameters",
    "title": "Integration",
    "section": "SLQ parameters",
    "text": "SLQ parameters\nThe trace estimator is fully configurable and thus has many parameters, both compile-time and run-time. It’s full signature is given below:\ntemplate&lt; \n  bool gramian, \n  std::floating_point DataType, \n  Operator Matrix, \n  ThreadSafeRBG RBG, \n  std::invocable&lt; DataType &gt; Func \n&gt; FlagType trace_estimator(\n    Matrix* A,\n    Func&& matrix_function,\n    RBG& rng,\n    const IndexType distr,\n    const DataType* parameters,\n    const IndexType num_parameters,\n    const FlagType orthogonalize,\n    const IndexType lanczos_degree,\n    const DataType lanczos_tol,\n    const IndexType min_num_samples,\n    const IndexType max_num_samples,\n    const DataType error_atol,\n    const DataType error_rtol,\n    const DataType confidence_level,\n    const DataType outlier_significance_level,\n    const IndexType num_threads,\n    DataType* trace,\n    DataType* error,\n    DataType** samples,\n    IndexType* processed_samples_indices,\n    IndexType* num_samples_used,\n    IndexType* num_outliers,\n    FlagType* converged,\n    DataType& alg_wall_time\n  )",
    "crumbs": [
      "Usage with C++"
    ]
  },
  {
    "objectID": "integration.html#example-log-determinant",
    "href": "integration.html#example-log-determinant",
    "title": "Integration",
    "section": "Example: Log determinant",
    "text": "Example: Log determinant\nFor explanatory purposes, the following code outline how to call the trace estimator to compute the log determinant using a custom user-implemented operator LinOp:\n#include &lt;cmath&gt;                              // std::log\n#include &lt;_linear_operator/linear_operator.h&gt; // LinearOperator\n#include &lt;_trace_estimator/trace_estimator.h&gt; // trace_estimator\n#include \"LinOp.h\"                            // custom LinOp class\n\nvoid slq_log_det(LinOp A, ...){ // LinOp must support .matvec() and .shape()\n  static_assert(LinearOperator&lt; LinOp &gt;);  // compile-time constraint check\n  static constexpr bool gramian = false;   // whether to compute the gramian\n  using float_t = A::value_type;           // the value type of the vectors\n  const auto matrix_func = std::log;       // any invocable will due\n  trace_estimator&lt; gramian, float_t &gt;(\n    A, matrix_func, ...                    // See SLQ parameters\n  ) \n}",
    "crumbs": [
      "Usage with C++"
    ]
  },
  {
    "objectID": "reference/random.normal.html",
    "href": "reference/random.normal.html",
    "title": "random.normal",
    "section": "",
    "text": "random.normal\nrandom.normal(size, engine='splitmix64', num_threads=1, seed=-1, dtype=np.float32)",
    "crumbs": [
      "API Reference",
      "random.normal"
    ]
  },
  {
    "objectID": "reference/api_index.html",
    "href": "reference/api_index.html",
    "title": "Function reference",
    "section": "",
    "text": "Trace estimation module\n\n\n\ntrace.slq\nEstimates the trace of a matrix function \\(f(A) = U f(D) U^{-1}\\) using the stochastic Lanczos quadrature (SLQ) method.\n\n\n\n\n\n\nRandomized module\n\n\n\nrandom.rademacher\nGenerates random vectors from the rademacher distribution.\n\n\nrandom.normal",
    "crumbs": [
      "API Reference",
      "Function reference"
    ]
  },
  {
    "objectID": "reference/api_index.html#primate.trace",
    "href": "reference/api_index.html#primate.trace",
    "title": "Function reference",
    "section": "",
    "text": "Trace estimation module\n\n\n\ntrace.slq\nEstimates the trace of a matrix function \\(f(A) = U f(D) U^{-1}\\) using the stochastic Lanczos quadrature (SLQ) method.",
    "crumbs": [
      "API Reference",
      "Function reference"
    ]
  },
  {
    "objectID": "reference/api_index.html#primate.random",
    "href": "reference/api_index.html#primate.random",
    "title": "Function reference",
    "section": "",
    "text": "Randomized module\n\n\n\nrandom.rademacher\nGenerates random vectors from the rademacher distribution.\n\n\nrandom.normal",
    "crumbs": [
      "API Reference",
      "Function reference"
    ]
  },
  {
    "objectID": "reference/index.html",
    "href": "reference/index.html",
    "title": "Function reference",
    "section": "",
    "text": "Trace estimation module\n\n\n\ntrace.slq\nEstimates the trace of a matrix function \\(f(A) = U f(D) U^{-1}\\) using the stochastic Lanczos quadrature (SLQ) method.\n\n\n\n\n\n\nRandomized module\n\n\n\nrandom.rademacher\nGenerates random vectors from the rademacher distribution.\n\n\nrandom.normal",
    "crumbs": [
      "API Reference"
    ]
  },
  {
    "objectID": "reference/index.html#primate.trace",
    "href": "reference/index.html#primate.trace",
    "title": "Function reference",
    "section": "",
    "text": "Trace estimation module\n\n\n\ntrace.slq\nEstimates the trace of a matrix function \\(f(A) = U f(D) U^{-1}\\) using the stochastic Lanczos quadrature (SLQ) method.",
    "crumbs": [
      "API Reference"
    ]
  },
  {
    "objectID": "reference/index.html#primate.random",
    "href": "reference/index.html#primate.random",
    "title": "Function reference",
    "section": "",
    "text": "Randomized module\n\n\n\nrandom.rademacher\nGenerates random vectors from the rademacher distribution.\n\n\nrandom.normal",
    "crumbs": [
      "API Reference"
    ]
  }
]